

# 1. Reverse an Array (In-place)
def reverse_array(arr):
    left, right = 0, len(arr) - 1
    while left < right:
        arr[left], arr[right] = arr[right], arr[left]
        left += 1
        right -= 1
    return arr


# 2. Find Minimum and Maximum in Array
def find_min_max(arr):
    return [min(arr), max(arr)]


# 3. Kth Smallest Element
def kth_smallest(arr, k):
    arr.sort()
    return arr[k - 1]


# 4. Union of Two Arrays
def union_arrays(a, b):
    return list(set(a) | set(b))


# 5. Largest Element in Array
def largest_element(arr):
    return max(arr)


# ==============================
# WEEK 2
# ==============================

# 6. Cyclically Rotate Array by One (Clockwise)
def rotate_by_one(arr):
    if len(arr) == 0:
        return arr
    last = arr.pop()
    arr.insert(0, last)
    return arr


# 7. Maximum Subarray Sum (Kadaneâ€™s Algorithm)
def max_subarray_sum(arr):
    max_current = arr[0]
    max_global = arr[0]
    for i in range(1, len(arr)):
        max_current = max(arr[i], max_current + arr[i])
        max_global = max(max_global, max_current)
    return max_global


# 8. Search Insert Position (Binary Search)
def search_insert(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return left


# 9. Two Sum
def two_sum(nums, target):
    num_map = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in num_map:
            return [num_map[complement], i]
        num_map[num] = i


# 10. Minimum Number of Jumps to Reach End
def min_jumps(arr):
    n = len(arr)
    if n <= 1:
        return 0
    if arr[0] == 0:
        return -1

    max_reach = arr[0]
    step = arr[0]
    jump = 1

    for i in range(1, n):
        if i == n - 1:
            return jump

        max_reach = max(max_reach, i + arr[i])
        step -= 1

        if step == 0:
            jump += 1
            if i >= max_reach:
                return -1
            step = max_reach - i

    return -1
