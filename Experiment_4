
# 1. Search Insert Position (Binary Search)
def search_insert(nums: List[int], target: int) -> int:
    l, r = 0, len(nums)-1
    while l <= r:
        m = (l+r)//2
        if nums[m] == target: return m
        elif nums[m] < target: l = m+1
        else: r = m-1
    return l

# 2. Combination Sum (Unlimited Use)
def combination_sum(candidates: List[int], target: int) -> List[List[int]]:
    res = []
    def backtrack(start, path, total):
        if total == target:
            res.append(path[:]); return
        if total > target: return
        for i in range(start, len(candidates)):
            backtrack(i, path+[candidates[i]], total+candidates[i])
    backtrack(0, [], 0)
    return res

# 3. Combination Sum II (Single Use, No Duplicates)
def combination_sum2(candidates: List[int], target: int) -> List[List[int]]:
    candidates.sort(); res = []
    def backtrack(start, path, total):
        if total == target:
            res.append(path[:]); return
        for i in range(start, len(candidates)):
            if i>start and candidates[i]==candidates[i-1]: continue
            if total+candidates[i] > target: break
            backtrack(i+1, path+[candidates[i]], total+candidates[i])
    backtrack(0, [], 0)
    return res

# 4. Jump Game II (Greedy)
def jump(nums: List[int]) -> int:
    jumps = curEnd = curFarthest = 0
    for i in range(len(nums)-1):
        curFarthest = max(curFarthest, i+nums[i])
        if i == curEnd:
            jumps += 1
            curEnd = curFarthest
    return jumps

# 5. Group Anagrams
def group_anagrams(strs: List[str]) -> List[List[str]]:
    d = defaultdict(list)
    for s in strs:
        d[tuple(sorted(s))].append(s)
    return list(d.values())

# 6. Plus One
def plus_one(digits: List[int]) -> List[int]:
    for i in range(len(digits)-1, -1, -1):
        if digits[i] < 9:
            digits[i] += 1; return digits
        digits[i] = 0
    return [1] + digits

# 7. Set Matrix Zeroes (In-place)
def set_zeroes(matrix: List[List[int]]) -> None:
    rows, cols = set(), set()
    for i in range(len(matrix)):
        for j in range(len(matrix[0])):
            if matrix[i][j] == 0:
                rows.add(i); cols.add(j)
    for i in range(len(matrix)):
        for j in range(len(matrix[0])):
            if i in rows or j in cols:
                matrix[i][j] = 0

# 8. Search in 2D Matrix (Binary Search)
def search_matrix(matrix: List[List[int]], target: int) -> bool:
    if not matrix: return False
    m, n = len(matrix), len(matrix[0])
    l, r = 0, m*n-1
    while l <= r:
        mid = (l+r)//2
        val = matrix[mid//n][mid%n]
        if val == target: return True
        elif val < target: l = mid+1
        else: r = mid-1
    return False

# 9. Sort Colors (Dutch National Flag)
def sort_colors(nums: List[int]) -> None:
    low = mid = 0; high = len(nums)-1
    while mid <= high:
        if nums[mid] == 0:
            nums[low], nums[mid] = nums[mid], nums[low]
            low+=1; mid+=1
        elif nums[mid] == 1:
            mid+=1
        else:
            nums[mid], nums[high] = nums[high], nums[mid]
            high-=1

# 10. Subsets (Power Set)
def subsets(nums: List[int]) -> List[List[int]]:
    res = [[]]
    for num in nums:
        res += [curr+[num] for curr in res]
    return res

# 11. Word Search (DFS Backtracking)
def exist(board: List[List[str]], word: str) -> bool:
    rows, cols = len(board), len(board[0])
    def dfs(r,c,i):
        if i == len(word): return True
        if r<0 or c<0 or r>=rows or c>=cols or board[r][c]!=word[i]:
            return False
        temp = board[r][c]; board[r][c] = "#"
        found = (dfs(r+1,c,i+1) or dfs(r-1,c,i+1) or
                 dfs(r,c+1,i+1) or dfs(r,c-1,i+1))
        board[r][c] = temp
        return found
    for i in range(rows):
        for j in range(cols):
            if dfs(i,j,0): return True
    return False

# 12. 4Sum
def four_sum(nums: List[int], target: int) -> List[List[int]]:
    nums.sort(); res = []
    n = len(nums)
    for i in range(n-3):
        if i>0 and nums[i]==nums[i-1]: continue
        for j in range(i+1,n-2):
            if j>i+1 and nums[j]==nums[j-1]: continue
            l, r = j+1, n-1
            while l<r:
                s = nums[i]+nums[j]+nums[l]+nums[r]
                if s==target:
                    res.append([nums[i],nums[j],nums[l],nums[r]])
                    l+=1; r-=1
                    while l<r and nums[l]==nums[l-1]: l+=1
                    while l<r and nums[r]==nums[r+1]: r-=1
                elif s<target: l+=1
                else: r-=1
    return res

# 13. Search in Rotated Sorted Array
def search_rotated(nums: List[int], target: int) -> int:
    l, r = 0, len(nums)-1
    while l<=r:
        m = (l+r)//2
        if nums[m]==target: return m
        if nums[l]<=nums[m]:
            if nums[l]<=target<nums[m]: r=m-1
            else: l=m+1
        else:
            if nums[m]<target<=nums[r]: l=m+1
            else: r=m-1
    return -1

# 14. First and Last Position of Target
def search_range(nums: List[int], target: int) -> List[int]:
    left = bisect_left(nums, target)
    right = bisect_right(nums, target)-1
    if left<=right: return [left,right]
    return [-1,-1]
