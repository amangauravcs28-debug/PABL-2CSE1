

# 1. Chocolate Distribution Problem
def chocolate_distribution(arr: List[int], m: int) -> int:
    if m > len(arr): return 0
    arr.sort()
    return min(arr[i+m-1] - arr[i] for i in range(len(arr)-m+1))

# 2. Smallest Subarray with Sum Greater Than X
def smallest_subarray(x: int, arr: List[int]) -> int:
    n, start, curr_sum, min_len = len(arr), 0, 0, float('inf')
    for end in range(n):
        curr_sum += arr[end]
        while curr_sum > x:
            min_len = min(min_len, end - start + 1)
            curr_sum -= arr[start]
            start += 1
    return 0 if min_len == float('inf') else min_len

# 3. Three Way Partitioning
def three_way_partition(arr: List[int], a: int, b: int) -> List[int]:
    low, mid, high = 0, 0, len(arr)-1
    while mid <= high:
        if arr[mid] < a:
            arr[low], arr[mid] = arr[mid], arr[low]
            low += 1; mid += 1
        elif arr[mid] > b:
            arr[mid], arr[high] = arr[high], arr[mid]
            high -= 1
        else:
            mid += 1
    return arr

# 4. Minimum Swaps to Bring <= k Together
def min_swaps(arr: List[int], k: int) -> int:
    count = sum(1 for x in arr if x <= k)
    bad = sum(1 for x in arr[:count] if x > k)
    ans = bad
    for i in range(len(arr)-count):
        if arr[i] > k: bad -= 1
        if arr[i+count] > k: bad += 1
        ans = min(ans, bad)
    return ans

# 5. Check if All Numbers are Palindrome
def all_palindrome(arr: List[int]) -> bool:
    return all(str(x) == str(x)[::-1] for x in arr)

# 6. Median of Array
def median_array(arr: List[int]) -> float:
    arr.sort()
    n = len(arr)
    return arr[n//2] if n%2 else (arr[n//2-1] + arr[n//2]) / 2

# 7. Spiral Traversal of Matrix
def spiral_traversal(mat: List[List[int]]) -> List[int]:
    res = []
    top, bottom, left, right = 0, len(mat)-1, 0, len(mat[0])-1
    while top <= bottom and left <= right:
        for i in range(left, right+1): res.append(mat[top][i])
        top += 1
        for i in range(top, bottom+1): res.append(mat[i][right])
        right -= 1
        if top <= bottom:
            for i in range(right, left-1, -1): res.append(mat[bottom][i])
            bottom -= 1
        if left <= right:
            for i in range(bottom, top-1, -1): res.append(mat[i][left])
            left += 1
    return res

# 8. Search in 2D Matrix (Binary Search O(log m*n))
def search_matrix(matrix: List[List[int]], target: int) -> bool:
    if not matrix: return False
    m, n = len(matrix), len(matrix[0])
    low, high = 0, m*n - 1
    while low <= high:
        mid = (low + high)//2
        val = matrix[mid//n][mid%n]
        if val == target: return True
        elif val < target: low = mid + 1
        else: high = mid - 1
    return False

# 9. Median in Row-wise Sorted Matrix
def matrix_median(mat: List[List[int]]) -> int:
    r, c = len(mat), len(mat[0])
    low, high = min(row[0] for row in mat), max(row[-1] for row in mat)
    desired = (r*c)//2
    while low < high:
        mid = (low + high)//2
        place = sum(bisect_right(row, mid) for row in mat)
        if place <= desired: low = mid + 1
        else: high = mid
    return low

# 10. Row with Maximum 1s
def row_with_max_ones(arr: List[List[int]]) -> int:
    max_row, max_count = -1, 0
    for i, row in enumerate(arr):
        count = len(row) - bisect_left(row, 1)
        if count > max_count:
            max_count = count
            max_row = i
    return max_row if max_count > 0 else -1
